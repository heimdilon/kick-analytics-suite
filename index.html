<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kick Live View + Chat Pulse</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0f1216;
      --bg-soft: #141a1f;
      --card: #181f26;
      --card-strong: #1d2630;
      --text: #e9eef4;
      --muted: #9fb0c0;
      --accent: #59f3a2;
      --accent-2: #4fd1c5;
      --warning: #ffb547;
      --danger: #ff6b6b;
      --shadow: rgba(10, 16, 22, 0.45);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", sans-serif;
      background: radial-gradient(1100px 600px at 10% -10%, rgba(89, 243, 162, 0.12), transparent 60%),
        radial-gradient(900px 500px at 90% 0%, rgba(79, 209, 197, 0.16), transparent 55%),
        linear-gradient(160deg, #0c0f13 0%, #0f1216 55%, #111821 100%);
      color: var(--text);
      min-height: 100vh;
    }

    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 40px 20px 60px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 28px;
    }

    .title-wrap {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    h1 {
      margin: 0;
      font-size: clamp(26px, 3vw, 36px);
      letter-spacing: -0.02em;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 15px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(89, 243, 162, 0.12);
      color: var(--accent);
      font-size: 13px;
      font-weight: 600;
    }

    .pill .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }

    .grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .card {
      background: var(--card);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 12px 30px var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .card strong {
      display: block;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .value {
      font-size: 28px;
      font-weight: 700;
      letter-spacing: -0.02em;
    }

    .value.small {
      font-size: 20px;
    }

    .controls {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      margin-bottom: 18px;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    input,
    select {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: var(--bg-soft);
      color: var(--text);
      font-size: 14px;
    }

    input::placeholder {
      color: rgba(159, 176, 192, 0.6);
    }

    button {
      border: none;
      border-radius: 12px;
      padding: 12px 16px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
      color: #0a1611;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover { transform: translateY(-1px); box-shadow: 0 8px 16px rgba(89, 243, 162, 0.25); }
    button:disabled { opacity: 0.6; cursor: not-allowed; transform: none; box-shadow: none; }

    .ghost {
      background: #26313c;
      color: var(--text);
    }

    .ghost:hover {
      box-shadow: 0 8px 16px rgba(38, 49, 60, 0.35);
    }

    .action-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 12px;
    }

    .status {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      background: var(--card-strong);
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 14px;
      color: var(--muted);
    }

    .status .tag {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      color: #0f1216;
      background: var(--warning);
    }

    .status.connected .tag { background: var(--accent); }
    .status.error .tag { background: var(--danger); color: #fff; }

    .chart-grid {
      margin-top: 18px;
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }

    .chart-card {
      background: var(--card);
      border-radius: 16px;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      min-height: 220px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .chart-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    .chart-meta {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      font-size: 12px;
      color: var(--muted);
    }

    .chart-value {
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
    }

    canvas {
      width: 100%;
      height: 160px;
      border-radius: 12px;
      background: rgba(10, 14, 20, 0.5);
    }

    .chat {
      background: rgba(13, 18, 24, 0.7);
      border-radius: 16px;
      padding: 16px;
      height: 320px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .chat-line {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      font-size: 14px;
    }

    .avatar {
      width: 28px;
      height: 28px;
      border-radius: 8px;
      background: #2a3542;
      display: grid;
      place-items: center;
      font-weight: 700;
    }

    .chat-meta {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
    }

    .chat-user {
      font-weight: 700;
      color: var(--text);
    }

    .helper {
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
      line-height: 1.4;
    }

    .advanced { margin-top: 12px; }

    .chart-card button { margin-top: 8px; }

    .top-list {
      font-size: 14px;
      line-height: 1.4;
      color: var(--text);
    }

    .chart-card.wide {
      grid-column: 1 / -1;
    }

    .heat-strip {
      display: grid;
      grid-template-columns: repeat(30, 1fr);
      gap: 4px;
      min-height: 110px;
    }

    .heat-cell {
      height: 12px;
      border-radius: 4px;
      background: rgba(89, 243, 162, 0.08);
      transition: background 0.2s ease;
    }

    .ticker {
      background: rgba(10, 14, 20, 0.55);
      border-radius: 12px;
      padding: 12px 14px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .ticker-track {
      display: inline-block;
      white-space: nowrap;
      animation: ticker-scroll var(--ticker-duration, 20s) linear infinite;
    }

    .ticker-track.paused {
      animation: none;
    }

    @keyframes ticker-scroll {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }

    .bar-list {
      display: grid;
      gap: 8px;
    }

    .bar-item {
      display: grid;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .bar-track {
      position: relative;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      border-radius: inherit;
      background: linear-gradient(135deg, rgba(89, 243, 162, 0.95), rgba(79, 209, 197, 0.85));
    }

    .emote-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .emote-card {
      background: rgba(10, 14, 20, 0.55);
      border-radius: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: grid;
      gap: 2px;
    }

    .emote-name {
      color: var(--text);
      font-weight: 600;
    }

    .sparkline {
      height: 140px;
      border-radius: 12px;
      background: rgba(10, 14, 20, 0.5);
    }

    @media (max-width: 720px) {
      header { flex-direction: column; align-items: flex-start; }
      .chat { height: 260px; }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="title-wrap">
        <h1>Kick Live View + Chat Pulse</h1>
        <p class="subtitle">Track live viewer count (if available) and unique chatters per second/minute.</p>
      </div>
      <div class="pill"><span class="dot"></span><span id="sessionStatus">Ready</span></div>
    </header>

    <section class="card">
      <div class="controls">
        <div>
          <label for="channelInput">Kick channel</label>
          <input id="channelInput" placeholder="xqc" autocomplete="off" />
        </div>
        <div>
          <label for="proxyInput">Optional proxy (for CORS)</label>
          <input id="proxyInput" placeholder="http://localhost:3456" autocomplete="off" />
        </div>
        <div>
          <label for="manualChatroom">Chatroom ID (optional)</label>
          <input id="manualChatroom" placeholder="e.g. 668" autocomplete="off" />
        </div>
        <div>
          <label for="windowSelect">Chart window</label>
          <select id="windowSelect">
            <option value="60">Last 60s</option>
            <option value="300">Last 5 min</option>
            <option value="900">Last 15 min</option>
            <option value="3600">Last 1 hour</option>
            <option value="all">All stream</option>
          </select>
        </div>
        <div style="display:flex; align-items:flex-end;">
          <button id="connectBtn">Connect</button>
        </div>
      </div>
      <div class="controls advanced">
        <div>
          <label for="durationInput">Auto stop after (sec)</label>
          <input id="durationInput" type="number" min="1" placeholder="e.g. 3600" />
        </div>
        <div>
          <label for="inactivityInput">Stop after inactivity (sec)</label>
          <input id="inactivityInput" type="number" min="1" placeholder="e.g. 300" />
        </div>
      </div>
      <div class="action-row">
        <button id="clearBtn" class="ghost">Clear Data</button>
        <button id="exportBtn" class="ghost">Export Session CSV</button>
        <button id="exportMessagesBtn" class="ghost">Export Messages CSV</button>
        <button id="exportJsonlBtn" class="ghost">Export Session JSONL</button>
      </div>
      <div class="status" id="statusBar">
        <span id="statusText">Waiting for a channel...</span>
        <span class="tag" id="statusTag">Idle</span>
      </div>
      <p class="helper">
        Viewer count depends on Kick API access. If you see "Unavailable", run the local proxy in `kick-chat-analytics/server.py` and set it above.
      </p>
    </section>

    <section class="grid" style="margin-top:18px;">
      <div class="card">
        <strong>Live Viewers</strong>
        <div class="value" id="viewerCount">Unavailable</div>
      </div>
      <div class="card">
        <strong>Messages / Minute</strong>
        <div class="value" id="messagesPerMinute">0</div>
      </div>
      <div class="card">
        <strong>Messages / Second</strong>
        <div class="value" id="messagesPerSecond">0.0</div>
      </div>
      <div class="card">
        <strong>Unique Chatters / Minute</strong>
        <div class="value" id="uniquePerMinute">0</div>
      </div>
      <div class="card">
        <strong>Viewers / Unique Chatter (1m)</strong>
        <div class="value" id="viewersPerUnique">Unavailable</div>
      </div>
      <div class="card">
        <strong>Unique Chatters / Second</strong>
        <div class="value" id="uniquePerSecond">0</div>
      </div>
      <div class="card">
        <strong>Total Unique Chatters</strong>
        <div class="value" id="uniqueTotal">0</div>
      </div>
      <div class="card">
        <strong>Total Messages</strong>
        <div class="value" id="totalMessages">0</div>
      </div>
      <div class="card">
        <strong>Total Emotes</strong>
        <div class="value" id="totalEmotes">0</div>
      </div>
      <div class="card">
        <strong>Emoji Rate</strong>
        <div class="value" id="emojiRate">0%</div>
      </div>
      <div class="card">
        <strong>Peak Messages / Minute</strong>
        <div class="value" id="peakMessagesPerMinute">0</div>
      </div>
      <div class="card">
        <strong>Spam Intensity (1m)</strong>
        <div class="value" id="spamRate">0%</div>
      </div>
      <div class="card">
        <strong>Top Chatters (Share)</strong>
        <div class="value small top-list" id="topChatters">n/a</div>
      </div>
    </section>

    <section class="chart-grid">
      <div class="chart-card">
        <div class="chart-title">Messages / Minute</div>
        <div class="chart-meta">
          <span class="chart-value" id="chartMessagesValue">0</span>
          <span id="chartMessagesWindow">Last 60s</span>
        </div>
        <canvas id="chartMessages"></canvas>
      </div>
      <div class="chart-card">
        <div class="chart-title">Unique Chatters / Minute</div>
        <div class="chart-meta">
          <span class="chart-value" id="chartUniqueValue">0</span>
          <span id="chartUniqueWindow">Last 60s</span>
        </div>
        <canvas id="chartUnique"></canvas>
      </div>
      <div class="chart-card">
        <div class="chart-title">Live Viewers (poll)</div>
        <div class="chart-meta">
          <span class="chart-value" id="chartViewersValue">Unavailable</span>
          <span id="chartViewersWindow">Last 60s</span>
        </div>
        <canvas id="chartViewers"></canvas>
      </div>
    </section>

    <section class="chart-grid" style="margin-top:18px;">
      <div class="chart-card wide">
        <div class="chart-title">Message Ticker (Last 10)</div>
        <div class="ticker">
          <div id="messageTicker" class="ticker-track">Waiting for messages...</div>
        </div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Message Heat (60m)</div>
        <div class="chart-meta">
          <span class="chart-value" id="heatMax">0</span>
          <span>per minute peak</span>
        </div>
        <div id="heatStrip" class="heat-strip"></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Live Pulse</div>
        <div class="chart-meta">
          <span class="chart-value">MPM vs Unique</span>
          <span>Last 2 min</span>
        </div>
        <canvas id="pulseSparkline" class="sparkline"></canvas>
      </div>
      <div class="chart-card">
        <div class="chart-title">Top Chatters Share</div>
        <div id="topChattersBars" class="bar-list"></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Top Emotes</div>
        <div id="emoteGrid" class="emote-grid"></div>
      </div>
    </section>

    <section class="card" style="margin-top:18px;">
      <strong>Recent Chat</strong>
      <div class="chat" id="chatContainer">
        <div class="helper">Messages will appear here once connected.</div>
      </div>
    </section>
  </div>

  <script>
    const els = {
      channelInput: document.getElementById("channelInput"),
      proxyInput: document.getElementById("proxyInput"),
      manualChatroom: document.getElementById("manualChatroom"),
      windowSelect: document.getElementById("windowSelect"),
      connectBtn: document.getElementById("connectBtn"),
      clearBtn: document.getElementById("clearBtn"),
      exportBtn: document.getElementById("exportBtn"),
      exportMessagesBtn: document.getElementById("exportMessagesBtn"),
      exportJsonlBtn: document.getElementById("exportJsonlBtn"),
      statusBar: document.getElementById("statusBar"),
      statusText: document.getElementById("statusText"),
      statusTag: document.getElementById("statusTag"),
      sessionStatus: document.getElementById("sessionStatus"),
      viewerCount: document.getElementById("viewerCount"),
      messagesPerMinute: document.getElementById("messagesPerMinute"),
      messagesPerSecond: document.getElementById("messagesPerSecond"),
      uniquePerMinute: document.getElementById("uniquePerMinute"),
      viewersPerUnique: document.getElementById("viewersPerUnique"),
      uniquePerSecond: document.getElementById("uniquePerSecond"),
      uniqueTotal: document.getElementById("uniqueTotal"),
      totalMessages: document.getElementById("totalMessages"),
      totalEmotes: document.getElementById("totalEmotes"),
      emojiRate: document.getElementById("emojiRate"),
      peakMessagesPerMinute: document.getElementById("peakMessagesPerMinute"),
      spamRate: document.getElementById("spamRate"),
      topChatters: document.getElementById("topChatters"),
      chatContainer: document.getElementById("chatContainer"),
      chartMessages: document.getElementById("chartMessages"),
      chartUnique: document.getElementById("chartUnique"),
      chartViewers: document.getElementById("chartViewers"),
      chartMessagesValue: document.getElementById("chartMessagesValue"),
      chartUniqueValue: document.getElementById("chartUniqueValue"),
      chartViewersValue: document.getElementById("chartViewersValue"),
      chartMessagesWindow: document.getElementById("chartMessagesWindow"),
      chartUniqueWindow: document.getElementById("chartUniqueWindow"),
      chartViewersWindow: document.getElementById("chartViewersWindow"),
      messageTicker: document.getElementById("messageTicker"),
      heatStrip: document.getElementById("heatStrip"),
      heatMax: document.getElementById("heatMax"),
      pulseSparkline: document.getElementById("pulseSparkline"),
      topChattersBars: document.getElementById("topChattersBars"),
      emoteGrid: document.getElementById("emoteGrid"),
      durationInput: document.getElementById("durationInput"),
      inactivityInput: document.getElementById("inactivityInput")
    };

    const state = {
      socket: null,
      isConnected: false,
      channelName: "",
      chatroomId: null,
      totalMessages: 0,
      totalEmotes: 0,
      messagesWithEmoji: 0,
      peakMessagesPerMinute: 0,
      minuteBuckets: [],
      currentMinuteStart: null,
      tickerMessages: [],
      emoteCounts: {},
      uniqueUsers: new Set(),
      userCounts: {},
      events: [],
      series: { messages: [], unique: [], viewers: [] },
      snapshots: [],
      messageLog: [],
      sessionLog: [],
      currentViewer: null,
      chartWindowSeconds: 60,
      // Keep enough historical points so the "All stream" window can show more than 1 hour
      // of data without clamping the arrays to the 3600s limit used for the 1h window.
      maxSeriesLength: 20000,
      maxSnapshotLength: 7200,
      maxSessionLogLength: 20000,
      viewerInterval: null,
      maxChatLines: 60,
      charts: {},
      startTime: null,
      lastMessageTime: null,
      durationSeconds: null,
      inactivitySeconds: null
    };

    function setStatus(text, tag, mode) {
      els.statusText.textContent = text;
      els.statusTag.textContent = tag;
      els.statusBar.className = "status" + (mode ? " " + mode : "");
      els.sessionStatus.textContent = tag;
    }

    function setButtonState(loading) {
      els.connectBtn.disabled = loading;
      els.connectBtn.textContent = loading ? "Connecting..." : (state.isConnected ? "Disconnect" : "Connect");
    }

    function sanitize(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    function csvEscape(value) {
      if (value === null || value === undefined) return "";
      const text = String(value);
      if (/[",\n]/.test(text)) {
        return "\"" + text.replace(/"/g, "\"\"") + "\"";
      }
      return text;
    }

    function parsePositiveInt(value) {
      const num = Number(value);
      if (!Number.isFinite(num) || num <= 0) return null;
      return Math.floor(num);
    }

    function formatRatio(value) {
      if (value === null || value === undefined || !Number.isFinite(value)) return "N/A";
      return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
    }

    function formatPercent(value) {
      if (!Number.isFinite(value)) return "0%";
      return (value * 100).toFixed(1) + "%";
    }

    const emojiRegex = (() => {
      try {
        return new RegExp("\\p{Extended_Pictographic}", "u");
      } catch (err) {
        return /[\u203C-\u3299\uD83C-\uDBFF\uDC00-\uDFFF]/;
      }
    })();

    function containsEmoji(text) {
      if (!text) return false;
      return emojiRegex.test(text);
    }

    function initHeatStrip() {
      if (!els.heatStrip) return;
      els.heatStrip.innerHTML = "";
      for (let i = 0; i < 60; i += 1) {
        const cell = document.createElement("div");
        cell.className = "heat-cell";
        els.heatStrip.appendChild(cell);
      }
    }

    function ensureMinuteBuckets(now) {
      const minuteStart = Math.floor(now / 60000) * 60000;
      if (state.currentMinuteStart === null) {
        state.currentMinuteStart = minuteStart;
        state.minuteBuckets = Array(60).fill(0);
        return;
      }
      if (minuteStart === state.currentMinuteStart) return;
      const diffMinutes = Math.min(60, Math.floor((minuteStart - state.currentMinuteStart) / 60000));
      for (let i = 0; i < diffMinutes; i += 1) {
        state.minuteBuckets.push(0);
        if (state.minuteBuckets.length > 60) state.minuteBuckets.shift();
      }
      state.currentMinuteStart = minuteStart;
    }

    function updateHeatStrip() {
      if (!els.heatStrip || !els.heatStrip.children.length) return;
      const max = Math.max(1, ...state.minuteBuckets);
      els.heatMax.textContent = max.toLocaleString();
      [...els.heatStrip.children].forEach((cell, idx) => {
        const value = state.minuteBuckets[idx] || 0;
        const intensity = value / max;
        const alpha = 0.12 + intensity * 0.7;
        cell.style.background = "rgba(89, 243, 162, " + alpha.toFixed(3) + ")";
      });
    }

    function updateTicker() {
      if (!els.messageTicker) return;
      if (!state.tickerMessages.length) {
        els.messageTicker.textContent = "Waiting for messages...";
        els.messageTicker.classList.add("paused");
        return;
      }
      const text = state.tickerMessages.join("  •  ");
      els.messageTicker.textContent = text + "  •  " + text;
      const base = Math.max(14, Math.min(40, Math.ceil(text.length / 6)));
      els.messageTicker.style.setProperty("--ticker-duration", base + "s");
      if (text.length < 50) {
        els.messageTicker.classList.add("paused");
      } else {
        els.messageTicker.classList.remove("paused");
      }
    }

    function updateTopChattersBars(topEntries) {
      if (!els.topChattersBars) return;
      if (!topEntries.length) {
        els.topChattersBars.innerHTML = "<div class=\"helper\">No activity yet.</div>";
        return;
      }
      const max = Math.max(...topEntries.map((item) => item.share));
      els.topChattersBars.innerHTML = topEntries.map((entry) => {
        const width = max > 0 ? Math.max(8, Math.round((entry.share / max) * 100)) : 0;
        return (
          "<div class=\"bar-item\">" +
            "<div>" + sanitize(entry.name) + " · " + formatPercent(entry.share) + "</div>" +
            "<div class=\"bar-track\"><div class=\"bar-fill\" style=\"width:" + width + "%\"></div></div>" +
          "</div>"
        );
      }).join("");
    }

    function updateEmoteGrid() {
      if (!els.emoteGrid) return;
      const entries = Object.entries(state.emoteCounts);
      if (!entries.length) {
        els.emoteGrid.innerHTML = "<div class=\"helper\">No emotes yet.</div>";
        return;
      }
      entries.sort((a, b) => b[1] - a[1]);
      const top = entries.slice(0, 8);
      els.emoteGrid.innerHTML = top.map(([name, count]) => (
        "<div class=\"emote-card\"><div class=\"emote-name\">" + sanitize(name) +
        "</div><div>" + count.toLocaleString() + " uses</div></div>"
      )).join("");
    }

    function drawSparkline() {
      const canvas = els.pulseSparkline;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const rect = canvas.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;
      canvas.width = rect.width * ratio;
      canvas.height = rect.height * ratio;
      ctx.scale(ratio, ratio);

      const messages = state.series.messages.slice(-120);
      const unique = state.series.unique.slice(-120);
      const max = Math.max(1, ...messages, ...unique);
      ctx.clearRect(0, 0, rect.width, rect.height);

      const drawLine = (data, color) => {
        if (!data.length) return;
        ctx.beginPath();
        data.forEach((value, index) => {
          const x = (index / (data.length - 1 || 1)) * rect.width;
          const y = rect.height - (value / max) * (rect.height - 12) - 6;
          if (index === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
      };

      drawLine(messages, "rgba(89, 243, 162, 0.9)");
      drawLine(unique, "rgba(79, 209, 197, 0.9)");
    }

    function recordSession(entry) {
      state.sessionLog.push(entry);
      if (state.sessionLog.length > state.maxSessionLogLength) {
        state.sessionLog.shift();
      }
    }

    function updateTopChatters() {
      const entries = Object.entries(state.userCounts);
      if (!entries.length) {
        els.topChatters.textContent = "n/a";
        updateTopChattersBars([]);
        return;
      }
      entries.sort((a, b) => b[1] - a[1]);
      const topEntries = entries.slice(0, 5).map(([name, count]) => {
        const share = state.totalMessages > 0 ? count / state.totalMessages : 0;
        return { name, count, share };
      });
      const topText = topEntries.map((entry) => (
        entry.name + " (" + entry.count + ", " + formatPercent(entry.share) + ")"
      ));
      els.topChatters.textContent = topText.join(", ");
      updateTopChattersBars(topEntries);
    }

    function createChart(canvas, color) {
      const ctx = canvas.getContext("2d");
      const chart = {
        ctx,
        color,
        data: []
      };

      function draw() {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        canvas.width = width * devicePixelRatio;
        canvas.height = height * devicePixelRatio;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(devicePixelRatio, devicePixelRatio);

        ctx.clearRect(0, 0, width, height);

        const data = chart.data.length ? chart.data : [0];
        const max = Math.max(1, ...data);
        const last = data[data.length - 1] ?? 0;

        ctx.lineWidth = 2;
        ctx.strokeStyle = color;
        ctx.beginPath();

        data.forEach((val, idx) => {
          const x = (idx / Math.max(1, data.length - 1)) * width;
          const y = height - (val / max) * (height - 12) - 6;
          if (idx === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });

        ctx.stroke();

        ctx.fillStyle = "rgba(255, 255, 255, 0.08)";
        ctx.fillRect(0, height - 1, width, 1);

        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        ctx.font = "10px Space Grotesk, sans-serif";
        ctx.fillText(String(Math.round(max)), 6, 12);
        ctx.fillText("0", 6, height - 6);
        ctx.fillText(String(Math.round(last)), width - 28, 12);
      }

      function setData(values) {
        chart.data = values;
        draw();
      }

      draw();
      return { setData, draw };
    }

    function setupCharts() {
      state.charts.messages = createChart(els.chartMessages, "#59f3a2");
      state.charts.unique = createChart(els.chartUnique, "#4fd1c5");
      state.charts.viewers = createChart(els.chartViewers, "#ffb547");
    }

    function formatWindowLabel(windowValue) {
      if (windowValue === "all") return "All stream";
      const seconds = Number(windowValue);
      if (seconds === 60) return "Last 60s";
      if (seconds === 300) return "Last 5 min";
      if (seconds === 900) return "Last 15 min";
      return "Last 1 hour";
    }

    function setChartWindow(windowValue) {
      state.chartWindowSeconds = windowValue;
      const label = formatWindowLabel(windowValue);
      els.chartMessagesWindow.textContent = label;
      els.chartUniqueWindow.textContent = label;
      els.chartViewersWindow.textContent = label;
      updateChartsFromSeries();
    }

    function getWindowData(series, length) {
      if (length === "all") {
        return series.length ? series.slice() : [0];
      }
      const slice = series.slice(-length);
      if (slice.length < length) {
        return new Array(length - slice.length).fill(0).concat(slice);
      }
      return slice;
    }

    function updateChartsFromSeries() {
      const length = state.chartWindowSeconds;
      state.charts.messages.setData(getWindowData(state.series.messages, length));
      state.charts.unique.setData(getWindowData(state.series.unique, length));
      state.charts.viewers.setData(getWindowData(state.series.viewers, length));
    }

    function pushSeries(name, value) {
      const arr = state.series[name];
      arr.push(value);
      if (arr.length > state.maxSeriesLength) arr.shift();
    }

    async function fetchChannelInfo(channel, proxyBase) {
      const manual = els.manualChatroom.value.trim();
      if (manual && /^\d+$/.test(manual)) {
        return { chatroomId: Number(manual), viewerCount: null, streamUrl: null };
      }

      if (proxyBase) {
        const base = proxyBase.replace(/\/$/, "");
        const resp = await fetch(base + "/channel?name=" + encodeURIComponent(channel));
        if (!resp.ok) throw new Error("Proxy did not return a chatroom id");
        const data = await resp.json();
        return { chatroomId: data.chatroomId, viewerCount: null, streamUrl: null };
      }

      const resp = await fetch("https://kick.com/api/v2/channels/" + encodeURIComponent(channel));
      if (!resp.ok) throw new Error("Kick API not reachable (CORS?)");
      const data = await resp.json();
      const viewerCount = data?.livestream?.viewer_count ?? data?.livestream?.viewerCount ?? null;
      const livestream = data?.livestream || {};
      const streamUrl = livestream?.playback_url || livestream?.playbackUrl || livestream?.hls || data?.playback_url || data?.playbackUrl || null;
      return { chatroomId: data?.chatroom?.id, viewerCount, streamUrl };
    }

    function startViewerPoll(channel, proxyBase) {
      if (state.viewerInterval) clearInterval(state.viewerInterval);
      if (proxyBase) {
        els.viewerCount.textContent = "Unavailable";
        state.currentViewer = null;
        return;
      }

      state.viewerInterval = setInterval(async () => {
        try {
          const info = await fetchChannelInfo(channel, "");
          updateViewerCount(info.viewerCount);
        } catch (err) {
          updateViewerCount(null);
        }
      }, 20000);
    }

    function updateViewerCount(viewerCount) {
      if (viewerCount === null || typeof viewerCount === "undefined") {
        els.viewerCount.textContent = "Unavailable";
        els.chartViewersValue.textContent = "Unavailable";
        state.currentViewer = null;
        return;
      }
      const value = Number(viewerCount);
      els.viewerCount.textContent = value.toLocaleString();
      els.chartViewersValue.textContent = value.toLocaleString();
      state.currentViewer = value;
    }

    function connectWebSocket(chatroomId) {
      return new Promise((resolve, reject) => {
        state.socket = new WebSocket("wss://ws-us2.pusher.com/app/32cbd69e4b950bf97679?protocol=7&client=js&version=8.0.1&flash=false");

        state.socket.onopen = () => {
          state.socket.send(JSON.stringify({
            event: "pusher:subscribe",
            data: { auth: "", channel: "chatrooms." + chatroomId + ".v2" }
          }));
        };

        state.socket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.event === "pusher_internal:subscription_succeeded") {
              resolve();
            }
            if (data.event === "App\\Events\\ChatMessageEvent") {
              const payload = JSON.parse(data.data);
              onChatMessage(payload);
            }
          } catch (err) {
            console.error("Socket parse error", err);
          }
        };

        state.socket.onerror = () => reject(new Error("WebSocket error"));
        state.socket.onclose = () => {
          if (state.isConnected) {
            setStatus("Disconnected", "Offline", "error");
            state.isConnected = false;
            setButtonState(false);
          }
        };

        setTimeout(() => reject(new Error("WebSocket timeout")), 12000);
      });
    }

    function onChatMessage(msg) {
      const now = Date.now();
      const username = msg?.sender?.username || "anon";
      const color = msg?.sender?.identity?.color || "#59f3a2";
      const content = msg?.content || "";

      const emoteMatches = content.match(/\[emote:[^\]]+\]/g) || [];
      state.totalEmotes += emoteMatches.length;
      const emoteRegex = /\[emote:\d+:([^\]]+)\]/g;
      let emoteMatch = emoteRegex.exec(content);
      while (emoteMatch) {
        const name = emoteMatch[1];
        state.emoteCounts[name] = (state.emoteCounts[name] || 0) + 1;
        emoteMatch = emoteRegex.exec(content);
      }
      const hasEmoji = emoteMatches.length > 0 || containsEmoji(content);
      if (hasEmoji) state.messagesWithEmoji += 1;
      ensureMinuteBuckets(now);
      if (state.minuteBuckets.length) {
        state.minuteBuckets[state.minuteBuckets.length - 1] += 1;
      }
      state.events.push({ ts: now, user: username });
      state.totalMessages += 1;
      state.uniqueUsers.add(username);
      state.userCounts[username] = (state.userCounts[username] || 0) + 1;
      state.lastMessageTime = now;
      state.tickerMessages.push(username + ": " + content);
      if (state.tickerMessages.length > 10) state.tickerMessages.shift();
      const messageEntry = {
        ts: new Date(now).toISOString(),
        channel: state.channelName || "manual",
        username,
        message: content
      };
      state.messageLog.push(messageEntry);
      recordSession({
        type: "message",
        ts: messageEntry.ts,
        channel: messageEntry.channel,
        username,
        message: content
      });

      addChatLine(username, content, color);
    }

    function addChatLine(username, content, color) {
      if (els.chatContainer.querySelector(".helper")) {
        els.chatContainer.innerHTML = "";
      }

      const row = document.createElement("div");
      row.className = "chat-line";
      row.innerHTML =
        '<div class="avatar" style="background:' + color + '">' + sanitize(username.slice(0, 1).toUpperCase()) +
        '</div><div><div class="chat-meta"><span class="chat-user" style="color:' + color + '">' +
        sanitize(username) + '</span><span>' + new Date().toLocaleTimeString() +
        '</span></div><div>' + sanitize(content) + '</div></div>';

      els.chatContainer.appendChild(row);
      while (els.chatContainer.children.length > state.maxChatLines) {
        els.chatContainer.removeChild(els.chatContainer.firstChild);
      }
      els.chatContainer.scrollTop = els.chatContainer.scrollHeight;
    }

    function updateAnalytics() {
      const now = Date.now();
      ensureMinuteBuckets(now);
      state.events = state.events.filter((evt) => evt.ts > now - 60000);

      const perMinute = state.events.length;
      const perSecond = state.events.filter((evt) => evt.ts > now - 1000).length;

      const uniqueMinute = new Set(state.events.map((evt) => evt.user)).size;
      const uniqueSecond = new Set(state.events.filter((evt) => evt.ts > now - 1000).map((evt) => evt.user)).size;
      const viewerToUniqueRatio =
        state.currentViewer !== null && uniqueMinute > 0 ? Number((state.currentViewer / uniqueMinute).toFixed(3)) : null;
      if (perMinute > state.peakMessagesPerMinute) state.peakMessagesPerMinute = perMinute;
      let spamCount = 0;
      const lastSeenByUser = {};
      for (const evt of state.events) {
        const lastSeen = lastSeenByUser[evt.user];
        if (lastSeen && evt.ts - lastSeen <= 5000) {
          spamCount += 1;
        }
        lastSeenByUser[evt.user] = evt.ts;
      }
      const spamRate = perMinute > 0 ? spamCount / perMinute : 0;
      const emojiRate = state.totalMessages > 0 ? state.messagesWithEmoji / state.totalMessages : 0;

      els.messagesPerMinute.textContent = perMinute.toLocaleString();
      els.messagesPerSecond.textContent = perSecond.toFixed(1);
      els.uniquePerMinute.textContent = uniqueMinute.toLocaleString();
      els.viewersPerUnique.textContent = viewerToUniqueRatio === null ? "N/A" : formatRatio(viewerToUniqueRatio);
      els.uniquePerSecond.textContent = uniqueSecond.toLocaleString();
      els.uniqueTotal.textContent = state.uniqueUsers.size.toLocaleString();
      els.totalMessages.textContent = state.totalMessages.toLocaleString();
      els.totalEmotes.textContent = state.totalEmotes.toLocaleString();
      els.emojiRate.textContent = formatPercent(emojiRate);
      els.peakMessagesPerMinute.textContent = state.peakMessagesPerMinute.toLocaleString();
      els.spamRate.textContent = formatPercent(spamRate);
      updateTopChatters();
      updateHeatStrip();
      updateTicker();
      updateEmoteGrid();

      if (state.isConnected) {
        if (state.durationSeconds && state.startTime && (now - state.startTime) / 1000 >= state.durationSeconds) {
          disconnect({ keepStatus: true });
          setStatus("Reached duration limit", "Stopped", "error");
          return;
        }
        if (state.inactivitySeconds && state.lastMessageTime && (now - state.lastMessageTime) / 1000 >= state.inactivitySeconds) {
          disconnect({ keepStatus: true });
          setStatus("Stopped after inactivity", "Stopped", "error");
          return;
        }
      }

      pushSeries("messages", perMinute);
      pushSeries("unique", uniqueMinute);
      pushSeries("viewers", state.currentViewer ?? 0);
      updateChartsFromSeries();
      drawSparkline();

      els.chartMessagesValue.textContent = perMinute.toLocaleString();
      els.chartUniqueValue.textContent = uniqueMinute.toLocaleString();
      if (state.currentViewer === null) {
        els.chartViewersValue.textContent = "Unavailable";
      } else {
        els.chartViewersValue.textContent = state.currentViewer.toLocaleString();
      }

      const snap = {
        ts: new Date().toISOString(),
        channel: state.channelName || "manual",
        messagesPerMinute: perMinute,
        messagesPerSecond: perSecond,
        uniquePerMinute: uniqueMinute,
        uniquePerSecond: uniqueSecond,
        viewerToUniqueRatio,
        totalMessages: state.totalMessages,
        uniqueTotal: state.uniqueUsers.size,
        totalEmotes: state.totalEmotes,
        emojiRate,
        peakMessagesPerMinute: state.peakMessagesPerMinute,
        spamRate,
        viewerCount: state.currentViewer
      };
      state.snapshots.push(snap);
      if (state.snapshots.length > state.maxSnapshotLength) state.snapshots.shift();

      if (state.isConnected) {
        recordSession({
          type: "snapshot",
          ts: snap.ts,
          channel: snap.channel,
          messages_per_minute: perMinute,
          messages_per_second: perSecond,
          unique_per_minute: uniqueMinute,
          unique_per_second: uniqueSecond,
          viewer_to_unique_ratio: viewerToUniqueRatio,
          total_messages: state.totalMessages,
          unique_total: state.uniqueUsers.size,
          total_emotes: state.totalEmotes,
          emoji_rate: emojiRate,
          peak_messages_per_minute: state.peakMessagesPerMinute,
          spam_rate: spamRate,
          viewer_count: state.currentViewer
        });
      }
    }

    async function connect() {
      const channel = els.channelInput.value.trim().toLowerCase();
      if (!channel && !els.manualChatroom.value.trim()) {
        setStatus("Enter a channel or chatroom id", "Input", "error");
        return;
      }

      const duration = parsePositiveInt(els.durationInput.value.trim());
      const inactivity = parsePositiveInt(els.inactivityInput.value.trim());
      setButtonState(true);
      setStatus("Resolving channel...", "Working", "");

      try {
        const proxyBase = els.proxyInput.value.trim();
        const info = await fetchChannelInfo(channel, proxyBase);
        if (!info.chatroomId) throw new Error("Chatroom id not found");

        state.chatroomId = info.chatroomId;
        state.channelName = channel || "manual";
        updateViewerCount(info.viewerCount);
        state.startTime = Date.now();
        state.lastMessageTime = state.startTime;
        state.durationSeconds = duration;
        state.inactivitySeconds = inactivity;

        setStatus("Connecting to chat...", "Working", "");
        await connectWebSocket(state.chatroomId);

        state.isConnected = true;
        recordSession({
          type: "session_start",
          ts: new Date().toISOString(),
          channel: state.channelName || "manual",
          chatroom_id: state.chatroomId
        });
        setStatus("Connected to " + state.channelName, "Live", "connected");
        setButtonState(false);
        startViewerPoll(channel, proxyBase);
      } catch (err) {
        setStatus(err.message, "Error", "error");
        setButtonState(false);
      }
    }

    function disconnect(options) {
      const opts = options || {};
      if (state.socket) state.socket.close();
      if (state.viewerInterval) clearInterval(state.viewerInterval);
      state.socket = null;
      state.isConnected = false;
      setButtonState(false);
      if (!opts.keepStatus) {
        setStatus("Disconnected", "Offline", "error");
      }
    }

    els.connectBtn.addEventListener("click", () => {
      if (state.isConnected) disconnect();
      else connect();
    });

    els.windowSelect.addEventListener("change", (event) => {
      const value = event.target.value;
      if (value === "all") {
        setChartWindow("all");
        return;
      }
      const seconds = Number(value);
      if (Number.isFinite(seconds)) setChartWindow(seconds);
    });

    els.clearBtn.addEventListener("click", () => {
      state.events = [];
      state.totalMessages = 0;
      state.totalEmotes = 0;
      state.messagesWithEmoji = 0;
      state.peakMessagesPerMinute = 0;
      state.minuteBuckets = Array(60).fill(0);
      state.currentMinuteStart = Math.floor(Date.now() / 60000) * 60000;
      state.tickerMessages = [];
      state.emoteCounts = {};
      state.uniqueUsers = new Set();
      state.userCounts = {};
      state.series = { messages: [], unique: [], viewers: [] };
      state.snapshots = [];
      state.messageLog = [];
      state.sessionLog = [];
      state.currentViewer = null;
      state.startTime = null;
      state.lastMessageTime = null;

      els.messagesPerMinute.textContent = "0";
      els.messagesPerSecond.textContent = "0.0";
      els.uniquePerMinute.textContent = "0";
      els.viewersPerUnique.textContent = "Unavailable";
      els.uniquePerSecond.textContent = "0";
      els.uniqueTotal.textContent = "0";
      els.totalMessages.textContent = "0";
      els.totalEmotes.textContent = "0";
      els.emojiRate.textContent = "0%";
      els.peakMessagesPerMinute.textContent = "0";
      els.spamRate.textContent = "0%";
      els.topChatters.textContent = "n/a";
      updateTopChattersBars([]);
      updateTicker();
      updateEmoteGrid();
      updateHeatStrip();
      drawSparkline();
      els.viewerCount.textContent = "Unavailable";
      els.chartMessagesValue.textContent = "0";
      els.chartUniqueValue.textContent = "0";
      els.chartViewersValue.textContent = "Unavailable";

      els.chatContainer.innerHTML = '<div class="helper">Messages will appear here once connected.</div>';
      updateChartsFromSeries();
      setStatus("Session cleared", "Cleared", "");
    });

    els.exportBtn.addEventListener("click", () => {
      if (!state.snapshots.length) {
        setStatus("No session data to export yet", "Empty", "error");
        return;
      }
      const header = [
        "timestamp",
        "channel",
        "messages_per_minute",
        "messages_per_second",
        "unique_per_minute",
        "unique_per_second",
        "viewer_to_unique_ratio",
        "total_messages",
        "unique_total",
        "total_emotes",
        "emoji_rate",
        "peak_messages_per_minute",
        "spam_rate",
        "viewer_count"
      ];
      const rows = state.snapshots.map((snap) => [
        csvEscape(snap.ts),
        csvEscape(snap.channel),
        csvEscape(snap.messagesPerMinute),
        csvEscape(snap.messagesPerSecond),
        csvEscape(snap.uniquePerMinute),
        csvEscape(snap.uniquePerSecond),
        csvEscape(snap.viewerToUniqueRatio === null ? "" : snap.viewerToUniqueRatio),
        csvEscape(snap.totalMessages),
        csvEscape(snap.uniqueTotal),
        csvEscape(snap.totalEmotes),
        csvEscape(snap.emojiRate),
        csvEscape(snap.peakMessagesPerMinute),
        csvEscape(snap.spamRate),
        csvEscape(snap.viewerCount === null ? "" : snap.viewerCount)
      ]);
      const csv = "\uFEFF" + [header.join(","), ...rows.map((r) => r.join(","))].join("\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      const safeName = (state.channelName || "session").replace(/[^a-z0-9-_]/gi, "_");
      link.href = url;
      link.download = "kick-session-" + safeName + "-" + new Date().toISOString().replace(/[:.]/g, "-") + ".csv";
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
      setStatus("CSV exported", "Exported", "connected");
    });

    els.exportMessagesBtn.addEventListener("click", () => {
      if (!state.messageLog.length) {
        setStatus("No messages to export yet", "Empty", "error");
        return;
      }
      const header = ["timestamp", "channel", "username", "message"];
      const rows = state.messageLog.map((entry) => [
        csvEscape(entry.ts),
        csvEscape(entry.channel),
        csvEscape(entry.username),
        csvEscape(entry.message)
      ]);
      const csv = "\uFEFF" + [header.join(","), ...rows.map((r) => r.join(","))].join("\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      const safeName = (state.channelName || "messages").replace(/[^a-z0-9-_]/gi, "_");
      link.href = url;
      link.download = "kick-messages-" + safeName + "-" + new Date().toISOString().replace(/[:.]/g, "-") + ".csv";
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
      setStatus("Messages CSV exported", "Exported", "connected");
    });

    els.exportJsonlBtn.addEventListener("click", () => {
      if (!state.sessionLog.length) {
        setStatus("No session data to export yet", "Empty", "error");
        return;
      }
      const jsonl = state.sessionLog.map((entry) => JSON.stringify(entry)).join("\n");
      const blob = new Blob([jsonl], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      const safeName = (state.channelName || "session").replace(/[^a-z0-9-_]/gi, "_");
      link.href = url;
      link.download = "kick-session-" + safeName + "-" + new Date().toISOString().replace(/[:.]/g, "-") + ".jsonl";
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
      setStatus("JSONL exported", "Exported", "connected");
    });

    setupCharts();
    initHeatStrip();
    ensureMinuteBuckets(Date.now());
    updateHeatStrip();
    setChartWindow(60);
    updateTopChatters();
    updateTicker();
    updateEmoteGrid();
    setInterval(updateAnalytics, 1000);
    window.addEventListener("resize", () => {
      updateChartsFromSeries();
      drawSparkline();
    });
  </script>
</body>
</html>
